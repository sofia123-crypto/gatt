# -*- coding: utf-8 -*-
"""gatt_version.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GfeSGwj-FV6VcZ91icWYHq2PnuwoqJBs
"""
import streamlit as st
import pandas as pd
from datetime import datetime, timedelta, time

st.set_page_config(page_title="🛠️ Calcul du Temps de Montage", layout="centered")
st.title("Estimation du Temps de Montage")


def trouver_disponibilite(date_jour, h_debut_jour, h_fin_jour, planning, temps_requis):
    debut_jour = datetime.combine(date_jour, h_debut_jour)
    fin_jour = datetime.combine(date_jour, h_fin_jour)

    taches = []
    for _, row in planning.iterrows():
        if row["date"] == str(date_jour):
            d = datetime.combine(date_jour, datetime.strptime(row["heure_debut"], "%H:%M").time())
            f = datetime.combine(date_jour, datetime.strptime(row["heure_fin"], "%H:%M").time())
            taches.append((d, f))
    taches.sort()

    plages_libres = []
    cursor = debut_jour
    for d, f in taches:
        if cursor < d:
            plages_libres.append((cursor, d))
        cursor = max(cursor, f)
    if cursor < fin_jour:
        plages_libres.append((cursor, fin_jour))

    temps_requis_td = timedelta(minutes=temps_requis)
    for debut, fin in plages_libres:
        duree = fin - debut
        if duree >= temps_requis_td:
            h_debut_montage = debut
            h_fin_montage = debut + temps_requis_td
            return f"🟢 Montage possible de {h_debut_montage.strftime('%H:%M')} à {h_fin_montage.strftime('%H:%M')}"

    return "❌ Pas assez de créneaux disponibles"


role = st.sidebar.selectbox("👤 Vous êtes :", ["Utilisateur", "Administrateur"])

if role == "Administrateur":
    mdp = st.text_input("🔐 Mot de passe administrateur", type="password")

    if mdp == "safran123":
        st.success("Accès administrateur accordé ✅")

        date_plan = st.date_input("📅 Date de planification", value=datetime.today())
        h_debut = st.time_input("Début de la journée", time(8, 0))
        h_fin = st.time_input("Fin de la journée", time(17, 0))

        if "admin_planning" not in st.session_state:
            st.session_state.admin_planning = []

        with st.form("form_admin"):
            col1, col2, col3 = st.columns([1, 1, 2])
            with col1:
                tache_debut = st.time_input("Début tâche", time(9, 0), key="start_admin")
            with col2:
                tache_fin = st.time_input("Fin tâche", time(10, 0), key="end_admin")
            with col3:
                tache_nom = st.text_input("📝 Nom de la tâche", key="nom_tache")

            add_btn = st.form_submit_button("➕ Ajouter la tâche")
            if add_btn and tache_debut < tache_fin:
                st.session_state.admin_planning.append(
                    (str(date_plan), tache_debut.strftime("%H:%M"), tache_fin.strftime("%H:%M"), tache_nom)
                )

        st.markdown("### 📌 Tâches planifiées :")
        for i, (jour, d, f, nom) in enumerate(st.session_state.admin_planning):
            st.text(f"{i+1}. {jour} | {d} → {f} | {nom}")

        col_reset, col_save = st.columns([1, 1])
        with col_reset:
            if st.button("🗑️ Réinitialiser le planning"):
                st.session_state.admin_planning.clear()
                st.success("Planning réinitialisé ✅")
        with col_save:
            if st.button("📂 Sauvegarder le planning"):
                df = pd.DataFrame(st.session_state.admin_planning, columns=["date", "heure_debut", "heure_fin", "nom"])
                df.to_csv("planning_admin.csv", index=False)
                st.success("Planning sauvegardé avec succès ✅")

            if st.session_state.admin_planning:
                import plotly.express as px

                st.markdown("### 📊 Visualisation Gantt")

                df_gantt = pd.DataFrame(st.session_state.admin_planning, columns=["date", "heure_debut", "heure_fin", "nom"])
                df_gantt["Début"] = pd.to_datetime(df_gantt["date"] + " " + df_gantt["heure_debut"])
                df_gantt["Fin"] = pd.to_datetime(df_gantt["date"] + " " + df_gantt["heure_fin"])

                # 🗓️ Formater la date (axe Y) en format court pour être clair
                df_gantt["Jour"] = pd.to_datetime(df_gantt["date"]).dt.strftime("%A %d/%m")  # Exemple : "Jeudi 27/06"
                df_gantt["Tâche"] = df_gantt["nom"]

                # 📊 Créer le Gantt : Axe Y = jour, Axe X = heure
                fig = px.timeline(
                    df_gantt,
                    x_start="Début",
                    x_end="Fin",
                    y="Jour",
                    color="Tâche",
                    title="📅 Planning Gantt par jour",
                )    

                # ✅ Inverser les jours pour ordre chronologique vertical
                fig.update_yaxes(autorange="reversed", title="Jour")

                # ✅ Formatter l'axe X pour n'afficher que les heures
                fig.update_xaxes(
                    tickformat="%H:%M",
                    title="Heure de la journée",
                    dtick=3600000  # 1 heure en ms
                )

                # ✅ Nettoyage layout
                fig.update_layout(
                    height=600,
                    margin=dict(l=50, r=50, t=50, b=50),
                    xaxis=dict(tickangle=-45),
                    legend_title_text="Tâche",
                    hoverlabel=dict(bgcolor="white", font_size=12),
                )

                st.plotly_chart(fig, use_container_width=True)

    else:
        st.warning("🔒 Accès refusé. Mot de passe incorrect.")

elif role == "Utilisateur":
    st.markdown("Chargez votre fichier de commande client (`commande_client.csv`).")

    try:
        base_df = pd.read_csv("Test_1.csv")
        base_df['temps_montage'] = base_df['temps_montage'].astype(int)
    except Exception as e:
        st.error(f"❌ Impossible de charger Test_1.csv : {e}")
        st.stop()

    commande_file = st.file_uploader("📌 Charger votre commande (commande_client.csv)", type="csv")

    def calculer_temps(commande_df, base_df):
        total = 0
        erreurs = []
        for _, ligne in commande_df.iterrows():
            ref = ligne['reference']
            qte = ligne['quantite']
            ligne_base = base_df[base_df['reference'] == ref]
            if not ligne_base.empty:
                try:
                    temps = int(ligne_base.iloc[0]['temps_montage'])
                    total += temps * qte
                except:
                    erreurs.append(f"Erreur conversion pour : {ref}")
            else:
                erreurs.append(f"Référence inconnue : {ref}")
        return total, erreurs

    if commande_file:
        try:
            commande_df = pd.read_csv(commande_file)
            commande_df['quantite'] = pd.to_numeric(commande_df['quantite'], errors='coerce').fillna(0).astype(int)

            st.markdown("### 🗓️ Planning de l'opérateur (chargé par l'admin)")
            try:
                df_plan = pd.read_csv("planning_admin.csv")
                for i, row in df_plan.iterrows():
                    st.text(f"{row['date']} : {row['heure_debut']} → {row['heure_fin']} | {row.get('nom', '')}")
            except:
                st.info("Aucun planning trouvé.")
                df_plan = pd.DataFrame(columns=["date", "heure_debut", "heure_fin"])

            if st.button("▶️ Lancer le calcul du temps de montage"):
                total, erreurs = calculer_temps(commande_df, base_df)

                if not df_plan.empty:
                    date_jour = pd.to_datetime(df_plan.iloc[0]["date"]).date()
                else:
                    date_jour = datetime.today().date()

                heure_debut_journee = time(8, 0)
                heure_fin_journee = time(17, 0)

                date_dispo = trouver_disponibilite(date_jour, heure_debut_journee, heure_fin_journee, df_plan, total)

                st.success(f"✅ Temps total : {total} minutes")
                st.info(f"📅 Date estimée de disponibilité : {date_dispo}")

                if erreurs:
                    st.warning("⚠️ Problèmes :")
                    for e in erreurs:
                        st.text(f" - {e}")
        except Exception as e:
            st.error(f"Erreur : {e}")

